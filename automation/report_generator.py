#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# 自动化报告生成器 - 生成投资分析和交易报告

from datetime import datetime, timedelta, date
from pathlib import Path
from typing import Dict, List, Any

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

from utils.logger import TradingLogger
from utils.notification import NotificationManager

# 可选的第三方库支持
try:
    import schedule
    SCHEDULE_AVAILABLE = True
except ImportError:
    SCHEDULE_AVAILABLE = False

# 可选的 ReportLab 支持
try:
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False

# 临时数据库类，直到真正的数据库实现完成
class BacktestDatabase:
    """临时回测数据库类"""
    def get_backtest_results(self, **kwargs):  # pylint: disable=unused-argument
        """返回示例回测结果"""
        return [
            {
                'strategy_name': 'RSI策略',
                'symbol': 'AAPL',
                'total_return': 0.15,
                'sharpe_ratio': 1.2,
                'max_drawdown': 0.08
            },
            {
                'strategy_name': 'MA策略',
                'symbol': 'MSFT',
                'total_return': 0.12,
                'sharpe_ratio': 1.1,
                'max_drawdown': 0.06
            }
        ]

    def get_trading_history(self, **kwargs):  # pylint: disable=unused-argument
        """返回示例交易历史"""
        return []

# 常量定义
TABLE_SECTION_CLOSE = """
            </table>
        </div>
        """

REPORT_FOOTER = """
        <div class="footer">
            <p>Generated by Automated Trading System</p>
            <p>Data for reference only. Trading involves risks.</p>
        </div>
    </body>
    </html>
    """

SCHEDULE_ERROR_MSG = "schedule库未安装，无法调度报告"
DATA_COLLECTION_ERROR = "数据收集失败"
REPORT_GENERATION_ERROR = "报告生成失败"


class ReportGenerator:
    """报告生成器基类"""

    def __init__(self):
        self.logger = TradingLogger(__name__)
        self.notification_manager = NotificationManager()
        self.db = BacktestDatabase()
        self.report_dir = Path("reports")
        self.report_dir.mkdir(exist_ok=True)

        # 设置matplotlib中文字体
        plt.rcParams['font.sans-serif'] = ['SimHei', 'DejaVu Sans']
        plt.rcParams['axes.unicode_minus'] = False

        # 设置seaborn样式
        sns.set_style("whitegrid")
        sns.set_palette("husl")

    def generate_daily_report(self, target_date: date = None) -> str:
        """生成日报"""
        if target_date is None:
            target_date = date.today()

        self.logger.log_system_event("生成日报", f"日期: {target_date}")

        # 收集当日数据
        daily_data = self._collect_daily_data(target_date)

        # 生成报告
        report_content = self._create_daily_report_content(daily_data, target_date)

        # 保存报告
        filename = f"daily_report_{target_date.strftime('%Y%m%d')}.html"
        filepath = self.report_dir / filename

        try:
            with open(filepath, 'w', encoding='utf-8', errors='replace') as f:
                f.write(report_content)
        except UnicodeEncodeError:
            # 如果UTF-8失败，使用ASCII编码并替换特殊字符
            with open(filepath, 'w', encoding='ascii', errors='replace') as f:
                f.write(report_content)

        self.logger.log_system_event("日报已生成", f"文件: {filepath}")

        # 发送通知
        self.notification_manager.send_notification(
            f"📊 日报已生成\n日期: {target_date}\n文件: {filename}",
            f"交易日报 - {target_date}"
        )

        return str(filepath)

    def generate_weekly_report(self, week_end_date: date = None) -> str:
        """生成周报"""
        if week_end_date is None:
            week_end_date = date.today()

        # 计算本周起始日期
        week_start_date = week_end_date - timedelta(days=week_end_date.weekday())

        self.logger.log_system_event("生成周报", f"周期: {week_start_date} 到 {week_end_date}")

        # 收集本周数据
        weekly_data = self._collect_weekly_data(week_start_date, week_end_date)

        # 生成报告
        report_content = self._create_weekly_report_content(weekly_data, week_start_date, week_end_date)

        # 保存报告
        filename = f"weekly_report_{week_start_date.strftime('%Y%m%d')}_{week_end_date.strftime('%Y%m%d')}.html"
        filepath = self.report_dir / filename

        try:
            with open(filepath, 'w', encoding='utf-8', errors='replace') as f:
                f.write(report_content)
        except UnicodeEncodeError:
            # 如果UTF-8失败，使用ASCII编码并替换特殊字符
            with open(filepath, 'w', encoding='ascii', errors='replace') as f:
                f.write(report_content)

        self.logger.log_system_event("周报已生成", f"文件: {filepath}")

        # 发送通知
        self.notification_manager.send_notification(
            f"📊 周报已生成\n周期: {week_start_date} 到 {week_end_date}\n文件: {filename}",
            f"交易周报 - 第{week_end_date.isocalendar()[1]}周"
        )

        return str(filepath)

    def generate_monthly_report(self, year: int = None, month: int = None) -> str:
        """生成月报"""
        if year is None:
            year = date.today().year
        if month is None:
            month = date.today().month

        # 计算月份起止日期
        month_start = date(year, month, 1)
        if month == 12:
            month_end = date(year + 1, 1, 1) - timedelta(days=1)
        else:
            month_end = date(year, month + 1, 1) - timedelta(days=1)

        self.logger.log_system_event("生成月报", f"月份: {year}年{month}月")

        # 收集本月数据
        monthly_data = self._collect_monthly_data(month_start, month_end)

        # 生成报告
        report_content = self._create_monthly_report_content(monthly_data, year, month)

        # 保存报告
        filename = f"monthly_report_{year}{month:02d}.html"
        filepath = self.report_dir / filename

        try:
            with open(filepath, 'w', encoding='utf-8', errors='replace') as f:
                f.write(report_content)
        except UnicodeEncodeError:
            # 如果UTF-8失败，使用ASCII编码并替换特殊字符
            with open(filepath, 'w', encoding='ascii', errors='replace') as f:
                f.write(report_content)

        self.logger.log_system_event("月报已生成", f"文件: {filepath}")

        # 发送通知
        self.notification_manager.send_notification(
            f"📊 月报已生成\n月份: {year}年{month}月\n文件: {filename}",
            f"交易月报 - {year}年{month}月"
        )

        return str(filepath)

    def _collect_daily_data(self, target_date: date) -> Dict[str, Any]:
        """收集日报数据"""
        data = {
            'date': target_date,
            'strategies_run': 0,
            'total_signals': 0,
            'profitable_trades': 0,
            'total_trades': 0,
            'best_strategy': None,
            'market_summary': {},
            'signals': [],
            'backtest_results': []
        }

        try:
            # 从数据库获取当日回测结果
            start_datetime = datetime.combine(target_date, datetime.min.time())
            end_datetime = datetime.combine(target_date, datetime.max.time())

            results = self.db.get_backtest_results(
                start_date=start_datetime,
                end_date=end_datetime
            )

            if results:
                data['backtest_results'] = results
                data['strategies_run'] = len(results)

                # 计算最佳策略
                best_result = max(results, key=lambda x: x.get('total_return', 0))
                data['best_strategy'] = {
                    'name': best_result.get('strategy_name', 'Unknown'),
                    'return': best_result.get('total_return', 0),
                    'symbol': best_result.get('symbol', 'Unknown')
                }

            # 模拟市场数据（实际应用中应从实时数据源获取）
            data['market_summary'] = self._get_market_summary()

        except (ImportError, FileNotFoundError, ValueError) as e:
            self.logger.log_error(DATA_COLLECTION_ERROR, f"收集日报数据失败: {e}")

        return data

    def _collect_weekly_data(self, start_date: date, end_date: date) -> Dict[str, Any]:
        """收集周报数据"""
        data = {
            'start_date': start_date,
            'end_date': end_date,
            'total_strategies_run': 0,
            'total_signals': 0,
            'weekly_performance': {},
            'strategy_comparison': [],
            'market_trends': {},
            'backtest_results': []
        }

        try:
            # 获取周期内的回测结果
            start_datetime = datetime.combine(start_date, datetime.min.time())
            end_datetime = datetime.combine(end_date, datetime.max.time())

            results = self.db.get_backtest_results(
                start_date=start_datetime,
                end_date=end_datetime
            )

            if results:
                data['backtest_results'] = results
                data['total_strategies_run'] = len(results)

                # 按策略分组统计
                strategy_stats = {}
                for result in results:
                    strategy_name = result.get('strategy_name', 'Unknown')
                    if strategy_name not in strategy_stats:
                        strategy_stats[strategy_name] = {
                            'count': 0,
                            'avg_return': 0,
                            'best_return': float('-inf'),
                            'worst_return': float('inf'),
                            'total_return': 0
                        }

                    stats = strategy_stats[strategy_name]
                    stats['count'] += 1
                    return_rate = result.get('total_return', 0)
                    stats['total_return'] += return_rate
                    stats['best_return'] = max(stats['best_return'], return_rate)
                    stats['worst_return'] = min(stats['worst_return'], return_rate)

                # 计算平均收益
                for strategy_name, stats in strategy_stats.items():
                    stats['avg_return'] = stats['total_return'] / stats['count']

                data['strategy_comparison'] = strategy_stats

        except (ImportError, FileNotFoundError, ValueError) as e:
            self.logger.log_error(DATA_COLLECTION_ERROR, f"收集周报数据失败: {e}")

        return data

    def _collect_monthly_data(self, start_date: date, end_date: date) -> Dict[str, Any]:
        """收集月报数据"""
        data = {
            'year': start_date.year,
            'month': start_date.month,
            'start_date': start_date,
            'end_date': end_date,
            'monthly_summary': {},
            'strategy_rankings': [],
            'performance_trends': {},
            'risk_analysis': {},
            'backtest_results': []
        }

        try:
            # 获取月度回测结果
            start_datetime = datetime.combine(start_date, datetime.min.time())
            end_datetime = datetime.combine(end_date, datetime.max.time())

            results = self.db.get_backtest_results(
                start_date=start_datetime,
                end_date=end_datetime
            )

            if results:
                data['backtest_results'] = results
                data['monthly_summary'] = self._calculate_monthly_summary(results)
                data['strategy_rankings'] = self._calculate_strategy_rankings(results)

        except (ImportError, FileNotFoundError, ValueError) as e:
            self.logger.log_error(DATA_COLLECTION_ERROR, f"收集月报数据失败: {e}")

        return data

    def _calculate_monthly_summary(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """计算月度摘要统计"""
        total_returns = [r.get('total_return', 0) for r in results]
        sharpe_ratios = [r.get('sharpe_ratio', 0) for r in results]
        max_drawdowns = [r.get('max_drawdown', 0) for r in results]

        return {
            'total_backtests': len(results),
            'avg_return': np.mean(total_returns) if total_returns else 0,
            'best_return': max(total_returns) if total_returns else 0,
            'worst_return': min(total_returns) if total_returns else 0,
            'avg_sharpe': np.mean(sharpe_ratios) if sharpe_ratios else 0,
            'avg_drawdown': np.mean(max_drawdowns) if max_drawdowns else 0,
            'success_rate': len([r for r in total_returns if r > 0]) / len(total_returns) if total_returns else 0
        }

    def _calculate_strategy_rankings(self, results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """计算策略排名"""
        strategy_performance = {}
        for result in results:
            strategy = result.get('strategy_name', 'Unknown')
            if strategy not in strategy_performance:
                strategy_performance[strategy] = []
            strategy_performance[strategy].append(result.get('total_return', 0))

        rankings = []
        for strategy, returns in strategy_performance.items():
            rankings.append({
                'strategy': strategy,
                'avg_return': np.mean(returns),
                'count': len(returns),
                'success_rate': len([r for r in returns if r > 0]) / len(returns)
            })

        return sorted(rankings, key=lambda x: x['avg_return'], reverse=True)

    def _get_market_summary(self) -> Dict[str, Any]:
        """获取市场摘要数据"""
        # 模拟数据，实际应用中应连接真实市场数据源
        return {
            'major_indices': {
                'S&P 500': {'value': 4500, 'change': 0.5},
                'NASDAQ': {'value': 15000, 'change': -0.2},
                'DOW': {'value': 35000, 'change': 0.8}
            },
            'market_mood': 'neutral',
            'volatility': 'low'
        }

    def _create_daily_report_content(self, data: Dict[str, Any], target_date: date) -> str:
        """创建日报HTML内容"""
        # 将中文日期转换为英文格式避免编码问题
        date_str = target_date.strftime('%Y-%m-%d')
        current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        html_content = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Daily Trading Report - {date_str}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }}
                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; text-align: center; }}
                .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }}
                .metric {{ background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #007bff; }}
                .metric-value {{ font-size: 24px; font-weight: bold; color: #007bff; }}
                .metric-label {{ font-size: 14px; color: #666; margin-top: 5px; }}
                .section {{ margin: 20px 0; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                .section h3 {{ color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }}
                table {{ width: 100%; border-collapse: collapse; margin: 10px 0; }}
                th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #f8f9fa; font-weight: bold; }}
                .positive {{ color: #28a745; }}
                .negative {{ color: #dc3545; }}
                .footer {{ text-align: center; color: #666; margin-top: 30px; font-size: 12px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Daily Trading Report</h1>
                <h2>{date_str}</h2>
                <p>Generated: {current_time}</p>
            </div>

            <div class="summary">
                <div class="metric">
                    <div class="metric-value">{data['strategies_run']}</div>
                    <div class="metric-label">Strategies Run</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{data['total_signals']}</div>
                    <div class="metric-label">Total Signals</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{data['total_trades']}</div>
                    <div class="metric-label">Executed Trades</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{data['profitable_trades']}</div>
                    <div class="metric-label">Profitable Trades</div>
                </div>
            </div>
        """

        # 最佳策略部分
        if data['best_strategy']:
            best = data['best_strategy']
            html_content += f"""
            <div class="section">
                <h3>Best Strategy Today</h3>
                <p><strong>Strategy:</strong> {best['name']}</p>
                <p><strong>Symbol:</strong> {best['symbol']}</p>
                <p><strong>Return:</strong> <span class="{'positive' if best['return'] > 0 else 'negative'}">{best['return']:.2%}</span></p>
            </div>
            """

        # 市场摘要
        market = data['market_summary']
        html_content += """
        <div class="section">
            <h3>Market Summary</h3>
            <table>
                <tr><th>Index</th><th>Value</th><th>Change</th></tr>
        """

        for index, info in market.get('major_indices', {}).items():
            # 提取嵌套条件表达式
            if info['change'] > 0:
                change_class = 'positive'
            elif info['change'] < 0:
                change_class = 'negative'
            else:
                change_class = ''

            html_content += f"""
                <tr>
                    <td>{index}</td>
                    <td>{info['value']}</td>
                    <td class="{change_class}">{info['change']:+.1f}%</td>
                </tr>
            """

        html_content += TABLE_SECTION_CLOSE

        # 回测结果
        if data['backtest_results']:
            html_content += """
            <div class="section">
                <h3>Backtest Results</h3>
                <table>
                    <tr><th>Strategy</th><th>Symbol</th><th>Return</th><th>Sharpe Ratio</th><th>Max Drawdown</th></tr>
            """

            for result in data['backtest_results']:
                return_class = 'positive' if result.get('total_return', 0) > 0 else 'negative'
                html_content += f"""
                    <tr>
                        <td>{result.get('strategy_name', 'Unknown')}</td>
                        <td>{result.get('symbol', 'Unknown')}</td>
                        <td class="{return_class}">{result.get('total_return', 0):.2%}</td>
                        <td>{result.get('sharpe_ratio', 0):.3f}</td>
                        <td>{result.get('max_drawdown', 0):.2%}</td>
                    </tr>
                """

            html_content += TABLE_SECTION_CLOSE

        # 结尾
        html_content += REPORT_FOOTER

        return html_content

    def _create_weekly_report_content(self, data: Dict[str, Any], start_date: date, end_date: date) -> str:
        """创建周报HTML内容"""
        week_num = end_date.isocalendar()[1]

        html_content = f"""
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>交易周报 - 第{week_num}周</title>
            <style>
                body {{ font-family: 'Microsoft YaHei', Arial, sans-serif; margin: 20px; line-height: 1.6; }}
                .header {{ background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 20px; border-radius: 10px; text-align: center; }}
                .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }}
                .metric {{ background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #11998e; }}
                .metric-value {{ font-size: 24px; font-weight: bold; color: #11998e; }}
                .metric-label {{ font-size: 14px; color: #666; margin-top: 5px; }}
                .section {{ margin: 20px 0; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                .section h3 {{ color: #333; border-bottom: 2px solid #11998e; padding-bottom: 10px; }}
                table {{ width: 100%; border-collapse: collapse; margin: 10px 0; }}
                th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #f8f9fa; font-weight: bold; }}
                .positive {{ color: #28a745; }}
                .negative {{ color: #dc3545; }}
                .footer {{ text-align: center; color: #666; margin-top: 30px; font-size: 12px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>📊 量化交易周报</h1>
                <h2>{start_date.year}年第{week_num}周</h2>
                <p>{start_date.strftime('%Y-%m-%d')} 至 {end_date.strftime('%Y-%m-%d')}</p>
                <p>生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>

            <div class="summary">
                <div class="metric">
                    <div class="metric-value">{data['total_strategies_run']}</div>
                    <div class="metric-label">策略运行总次数</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{len(data['strategy_comparison'])}</div>
                    <div class="metric-label">活跃策略数</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{data['total_signals']}</div>
                    <div class="metric-label">交易信号总数</div>
                </div>
            </div>
        """

        # 策略比较
        if data['strategy_comparison']:
            html_content += """
            <div class="section">
                <h3>📊 策略表现对比</h3>
                <table>
                    <tr><th>策略名称</th><th>运行次数</th><th>平均收益率</th><th>最佳收益</th><th>最差收益</th></tr>
            """

            for strategy, stats in data['strategy_comparison'].items():
                avg_class = 'positive' if stats['avg_return'] > 0 else 'negative'
                best_class = 'positive' if stats['best_return'] > 0 else 'negative'
                worst_class = 'positive' if stats['worst_return'] > 0 else 'negative'

                html_content += f"""
                    <tr>
                        <td>{strategy}</td>
                        <td>{stats['count']}</td>
                        <td class="{avg_class}">{stats['avg_return']:.2%}</td>
                        <td class="{best_class}">{stats['best_return']:.2%}</td>
                        <td class="{worst_class}">{stats['worst_return']:.2%}</td>
                    </tr>
                """

            html_content += TABLE_SECTION_CLOSE

        # 结尾
        html_content += REPORT_FOOTER

        return html_content

    def _create_monthly_report_content(self, data: Dict[str, Any], year: int, month: int) -> str:
        """创建月报HTML内容"""
        summary = data['monthly_summary']

        html_content = f"""
        <!DOCTYPE html>
        <html lang="zh-CN">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>交易月报 - {year}年{month}月</title>
            <style>
                body {{ font-family: 'Microsoft YaHei', Arial, sans-serif; margin: 20px; line-height: 1.6; }}
                .header {{ background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; text-align: center; }}
                .summary {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin: 20px 0; }}
                .metric {{ background: #f8f9fa; padding: 15px; border-radius: 8px; text-align: center; border-left: 4px solid #667eea; }}
                .metric-value {{ font-size: 20px; font-weight: bold; color: #667eea; }}
                .metric-label {{ font-size: 12px; color: #666; margin-top: 5px; }}
                .section {{ margin: 20px 0; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
                .section h3 {{ color: #333; border-bottom: 2px solid #667eea; padding-bottom: 10px; }}
                table {{ width: 100%; border-collapse: collapse; margin: 10px 0; }}
                th, td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}
                th {{ background-color: #f8f9fa; font-weight: bold; }}
                .positive {{ color: #28a745; }}
                .negative {{ color: #dc3545; }}
                .footer {{ text-align: center; color: #666; margin-top: 30px; font-size: 12px; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>📊 量化交易月报</h1>
                <h2>{year}年{month}月</h2>
                <p>生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            </div>

            <div class="summary">
                <div class="metric">
                    <div class="metric-value">{summary.get('total_backtests', 0)}</div>
                    <div class="metric-label">回测总次数</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{summary.get('avg_return', 0):.2%}</div>
                    <div class="metric-label">平均收益率</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{summary.get('best_return', 0):.2%}</div>
                    <div class="metric-label">最佳收益率</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{summary.get('avg_sharpe', 0):.3f}</div>
                    <div class="metric-label">平均夏普比率</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{summary.get('success_rate', 0):.1%}</div>
                    <div class="metric-label">成功率</div>
                </div>
                <div class="metric">
                    <div class="metric-value">{summary.get('avg_drawdown', 0):.2%}</div>
                    <div class="metric-label">平均最大回撤</div>
                </div>
            </div>
        """

        # 策略排名
        if data['strategy_rankings']:
            html_content += """
            <div class="section">
                <h3>🏆 策略排名 (按平均收益率)</h3>
                <table>
                    <tr><th>排名</th><th>策略名称</th><th>平均收益率</th><th>运行次数</th><th>成功率</th></tr>
            """

            for i, ranking in enumerate(data['strategy_rankings'], 1):
                return_class = 'positive' if ranking['avg_return'] > 0 else 'negative'

                html_content += f"""
                    <tr>
                        <td>{i}</td>
                        <td>{ranking['strategy']}</td>
                        <td class="{return_class}">{ranking['avg_return']:.2%}</td>
                        <td>{ranking['count']}</td>
                        <td>{ranking['success_rate']:.1%}</td>
                    </tr>
                """

            html_content += """
                </table>
            </div>
            """

        # 结尾
        html_content += REPORT_FOOTER

        return html_content


class AutoReportScheduler:
    """自动报告调度器"""

    def __init__(self):
        self.report_generator = ReportGenerator()
        self.logger = TradingLogger(__name__)

    def schedule_daily_reports(self, time_str: str = "18:00"):
        """调度日报生成"""
        if not SCHEDULE_AVAILABLE:
            self.logger.log_error("依赖缺失", SCHEDULE_ERROR_MSG)
            return

        schedule.every().day.at(time_str).do(self._generate_daily_report)
        self.logger.log_system_event("调度日报", f"每日 {time_str}")

    def schedule_weekly_reports(self, day: str = "monday", time_str: str = "09:00"):
        """调度周报生成"""
        if not SCHEDULE_AVAILABLE:
            self.logger.log_error("依赖缺失", SCHEDULE_ERROR_MSG)
            return

        getattr(schedule.every(), day.lower()).at(time_str).do(self._generate_weekly_report)
        self.logger.log_system_event("调度周报", f"每周{day} {time_str}")

    def schedule_monthly_reports(self, day: int = 1, time_str: str = "09:00"):
        """调度月报生成"""
        if not SCHEDULE_AVAILABLE:
            self.logger.log_error("依赖缺失", SCHEDULE_ERROR_MSG)
            return

        # schedule 库不支持月度调度，这里使用日调度作为替代
        schedule.every().day.at(time_str).do(self._generate_monthly_report)
        self.logger.log_system_event("调度月报", f"每月{day}日 {time_str}")

    def _generate_daily_report(self):
        """生成日报的包装函数"""
        try:
            self.report_generator.generate_daily_report()
        except (ImportError, FileNotFoundError, ValueError) as e:
            self.logger.log_error(REPORT_GENERATION_ERROR, f"日报生成失败: {e}")

    def _generate_monthly_report(self):
        """生成月报的包装函数"""
        try:
            self.report_generator.generate_monthly_report()
        except (ImportError, FileNotFoundError, ValueError) as e:
            self.logger.log_error(REPORT_GENERATION_ERROR, f"月报生成失败: {e}")

    def _generate_weekly_report(self):
        """生成周报的包装函数"""
        try:
            self.report_generator.generate_weekly_report()
        except (ImportError, FileNotFoundError, ValueError) as e:
            self.logger.log_error(REPORT_GENERATION_ERROR, f"周报生成失败: {e}")

    def _check_monthly_report(self):
        """检查是否需要生成月报"""
        today = date.today()
        if today.day == 1:  # 每月1日生成上月报告
            try:
                last_month = today.replace(day=1) - timedelta(days=1)
                self.report_generator.generate_monthly_report(
                    last_month.year,
                    last_month.month
                )
            except (ImportError, FileNotFoundError, ValueError) as e:
                self.logger.log_error(REPORT_GENERATION_ERROR, f"月报生成失败: {e}")


# 示例用法
if __name__ == "__main__":
    # 创建报告生成器
    generator = ReportGenerator()

    # 生成今日报告
    DAILY_REPORT = generator.generate_daily_report()
    print(f"日报已生成: {DAILY_REPORT}")

    # 生成本周报告
    WEEKLY_REPORT = generator.generate_weekly_report()
    print(f"周报已生成: {WEEKLY_REPORT}")

    # 生成本月报告
    MONTHLY_REPORT = generator.generate_monthly_report()
    print(f"月报已生成: {MONTHLY_REPORT}")
